name: Update Dependencies

on:
  schedule:
    # Run weekly on Sundays at 2 AM UTC (1 hour before main repo)
    - cron: "0 2 * * 0"
  workflow_dispatch:
    inputs:
      update-type:
        description: "Type of update to perform"
        required: true
        type: choice
        options:
          - "all"
          - "nixpkgs"
          - "nix-darwin"
          - "home-manager"
          - "catppuccin"
          - "ghostty"
          - "nvf-config"
          - "other"
        default: "all"
      create-pr:
        description: "Create a pull request with the updates"
        required: false
        type: boolean
        default: true
      branch-name:
        description: "Branch name to use for the update"
        required: false
        type: string
        default: "update-dependencies"

jobs:
  update-dependencies:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes

      - name: Setup Cachix
        uses: cachix/cachix-action@v16
        with:
          name: nix-community
          skipPush: true

      - name: Cache Nix store
        uses: nix-community/cache-nix-action@v7
        with:
          primary-key: nix-${{ runner.os }}-${{ hashFiles('flake.lock') }}
          restore-prefixes-first-match: nix-${{ runner.os }}-
          gc-max-store-size-linux: 1G

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check for existing PR
        id: check-pr
        run: |
          # Determine base branch from which the workflow was triggered
          # For scheduled runs, use default branch; for workflow_dispatch, use the branch it was triggered from
          BASE_BRANCH="${{ github.ref_name }}"
          # Remove 'refs/heads/' prefix if present
          BASE_BRANCH="${BASE_BRANCH#refs/heads/}"
          echo "Using base branch: $BASE_BRANCH"

          # Construct branch name with base branch suffix
          BASE_BRANCH_NAME="${{ github.event.inputs.branch-name || 'update-dependencies' }}"
          BRANCH_NAME="${BASE_BRANCH_NAME}-${BASE_BRANCH}"
          echo "Using branch name: $BRANCH_NAME"

          # Check for existing open PRs with head branch
          EXISTING_PR=$(gh pr list --base "$BASE_BRANCH" --state open --head "$BRANCH_NAME" --json number --jq '.[0] // empty')

          if [ -n "$EXISTING_PR" ]; then
            PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.number')
            echo "Found existing PR #$PR_NUMBER on branch $BRANCH_NAME targeting $BASE_BRANCH"
            echo "pr-exists=true" >> $GITHUB_OUTPUT
            echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
          else
            echo "No existing PR found"
            echo "pr-exists=false" >> $GITHUB_OUTPUT
          fi
          echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "base-branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare branch
        run: |
          BRANCH_NAME="${{ steps.check-pr.outputs.branch-name }}"
          BASE_BRANCH="${{ steps.check-pr.outputs.base-branch }}"
          # Always start fresh from target: one commit, full diff, complete change list
          git fetch origin "$BASE_BRANCH" --depth=1
          git checkout "origin/$BASE_BRANCH" -B "$BRANCH_NAME"
          echo "Branch $BRANCH_NAME reset from origin/$BASE_BRANCH (fresh update)"

      - name: Update dependencies
        id: update
        run: |
          set -o pipefail
          echo "Updating dependencies..."

          case "${{ github.event.inputs.update-type || 'all' }}" in
            "all")
              echo "Updating all dependencies..."
              nix flake update --accept-flake-config 2>&1 | tee /tmp/update.log
              ;;
            "nixpkgs")
              echo "Updating nixpkgs..."
              nix flake update --update-input nixpkgs --accept-flake-config 2>&1 | tee /tmp/update.log
              ;;
            "nix-darwin")
              echo "Updating nix-darwin..."
              nix flake update --update-input nix-darwin --accept-flake-config 2>&1 | tee /tmp/update.log
              ;;
            "home-manager")
              echo "Updating home-manager..."
              nix flake update --update-input home-manager --accept-flake-config 2>&1 | tee /tmp/update.log
              ;;
            "catppuccin")
              echo "Updating catppuccin themes..."
              nix flake update --update-input catppuccin --update-input catppuccin-vsc --accept-flake-config 2>&1 | tee /tmp/update.log
              ;;
            "ghostty")
              echo "Updating ghostty..."
              nix flake update --update-input ghostty --accept-flake-config 2>&1 | tee /tmp/update.log
              ;;
            "nvf-config")
              echo "Updating nvf-config..."
              nix flake update --update-input nvf-config --accept-flake-config 2>&1 | tee /tmp/update.log
              ;;
            "other")
              echo "Updating other dependencies..."
              nix flake update --accept-flake-config 2>&1 | tee /tmp/update.log
              ;;
          esac

          # Check if there are any changes
          if git diff --quiet; then
            echo "No changes to dependencies"
            echo "has-changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changes detected, generating updates list from nix flake update output..."

          # Parse "• Updated input 'name':" / "• Added input 'name':" and revs + dates from Nix output.
          # Updated: two lines (old url, then "→" new url). Added: one line 'url' (date) when there was no lock.
          # Rev: prefer ?rev= or &rev= (git); else flakehub version from path; else last path segment (7 chars).
          echo "## Updated inputs" > dependency-updates.md
          echo "" >> dependency-updates.md
          name=""
          old_rev=""
          old_date=""
          is_added=""
          rev_from_url() {
            local u="$1" v
            if [[ "$u" == *"rev="* ]]; then
              echo "$u" | sed -n 's/.*[?&]rev=\([^&]*\).*/\1/p' | head -c 7
              return
            fi
            if [[ "$u" == *"flakehub"* ]]; then
              v=$(echo "$u" | sed 's/?.*//' | sed -n 's/.*\/\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)\/.*/\1/p')
              [[ -n "$v" ]] && echo "$v" && return
            fi
            echo "$u" | sed 's/?.*//' | sed -n 's/.*\///p' | head -c 7
          }
          date_from_line() { echo "$1" | sed -n 's/.*(\([0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]\)).*/\1/p'; }
          while IFS= read -r line; do
            if [[ "$line" == *"Added input"* ]]; then
              name=$(echo "$line" | sed -n "s/.*Added input '\([^']*\)':.*/\1/p")
              old_rev=""
              old_date=""
              is_added=1
            elif [[ "$line" == *"Updated input"* ]]; then
              name=$(echo "$line" | sed -n "s/.*Updated input '\([^']*\)':.*/\1/p")
              old_rev=""
              old_date=""
              is_added=""
            elif [[ -n "$name" && "$line" == *"→"* ]]; then
              rest="${line#*\'}"; new_url="${rest%%\'*}"
              new_rev=$(rev_from_url "$new_url")
              new_date=$(date_from_line "$line")
              if [[ -n "$old_rev" ]]; then
                echo "**$name:**" >> dependency-updates.md
                echo "-  \`${old_rev}\` (${old_date}) ->" >> dependency-updates.md
                echo "-  \`${new_rev}\` (${new_date})" >> dependency-updates.md
                echo "" >> dependency-updates.md
              fi
              name=""
              is_added=""
            elif [[ -n "$name" && "$line" == *"'"* ]]; then
              rest="${line#*\'}"; url="${rest%%\'*}"
              rev=$(rev_from_url "$url")
              date=$(date_from_line "$line")
              if [[ -n "$is_added" ]]; then
                # Skip "follows '...'" lines (no rev/date); only emit when we have a real pin
                if [[ "$line" != *"follows"* && ( -n "$date" || "$url" == *"github:"* || "$url" == *"git+"* ) ]]; then
                  echo "**$name:**" >> dependency-updates.md
                  [[ -n "$date" ]] && echo "-  \`${rev}\` (${date}) (new)" >> dependency-updates.md || echo "-  \`${rev}\` (new)" >> dependency-updates.md
                  echo "" >> dependency-updates.md
                fi
                name=""
                is_added=""
              else
                old_rev="$rev"
                old_date="$date"
              fi
            fi
          done < /tmp/update.log
          echo "Updated inputs list: $(wc -l < dependency-updates.md) lines (header + blank + entries)"

          echo "Committing update..."

          # Add the flake.lock changes
          git add flake.lock
          git commit -m "Update dependencies (${{ github.event.inputs.update-type || 'all' }})"

          # Force-push so we overwrite any previous update branch (single commit, fresh from target)
          BRANCH_NAME="${{ steps.check-pr.outputs.branch-name }}"
          git push --force origin "$BRANCH_NAME"
          echo "has-changes=true" >> $GITHUB_OUTPUT

      - name: No changes detected
        if: steps.update.outputs.has-changes == 'false'
        run: |
          echo "✅ Dependencies are already up to date - no changes needed"

      - name: Test updated dependencies
        if: steps.update.outputs.has-changes == 'true'
        run: |
          echo "Testing updated dependencies..."
          nix flake check --accept-flake-config
          echo "✅ Dependency update validation passed"

      - name: Create Pull Request
        if: ${{ (github.event.inputs.create-pr || 'true') == 'true' && steps.update.outputs.has-changes == 'true' && steps.check-pr.outputs.pr-exists == 'false' }}
        run: |
          BRANCH_NAME="${{ steps.check-pr.outputs.branch-name }}"
          BASE_BRANCH="${{ steps.check-pr.outputs.base-branch }}"

          {
            echo "This PR updates the flake dependencies."
            echo ""
            if [ -s dependency-updates.md ]; then
              cat dependency-updates.md
              echo ""
            fi
            echo "**Testing:**"
            echo "- [x] Dependency validation passed"
            echo "- [ ] Build check workflow passes"
          } > pr-body.md

          PR_URL=$(gh pr create \
            --title "Update dependencies (${{ github.event.inputs.update-type || 'all' }}) → $BASE_BRANCH" \
            --body-file pr-body.md \
            --head "$BRANCH_NAME" \
            --base "$BASE_BRANCH")

          # Extract PR number from URL (format: https://github.com/owner/repo/pull/123)
          PR_NUMBER=$(echo "$PR_URL" | sed -E 's/.*\/pull\/([0-9]+).*/\1/')

          # Set default merge method to squash
          gh api \
            -X PATCH \
            repos/${{ github.repository }}/pulls/$PR_NUMBER \
            -f merge_method=squash
          echo "✅ Created PR #$PR_NUMBER with squash and merge as default"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update existing Pull Request
        if: ${{ (github.event.inputs.create-pr || 'true') == 'true' && steps.update.outputs.has-changes == 'true' && steps.check-pr.outputs.pr-exists == 'true' }}
        run: |
          PR_NUMBER="${{ steps.check-pr.outputs.pr-number }}"
          {
            echo "This PR updates the flake dependencies."
            echo ""
            if [ -s dependency-updates.md ]; then
              cat dependency-updates.md
              echo ""
            fi
            echo "**Testing:**"
            echo "- [x] Dependency validation passed"
            echo "- [ ] Build check workflow passes"
          } > pr-body.md
          gh pr edit "$PR_NUMBER" --body-file pr-body.md
          echo "✅ Updated existing PR #$PR_NUMBER with latest dependency changes"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
